## Lab 3 - Мікросервиси з використанням Hazelcast Distributed Map

### Огляд змін в сервісах
У якості каналу доставки повідомлень між facade-service та messages-service використа но Hazelcast Distributed Queue
Додано можливість запускати одночасно декілька копій messages-service
facade-service випадковим чином обирає до якої копії messages-service звертатись для читання повідомлень 

### Демонстрація роботи

- Необхідно розгорнути Messaging queue - Hazelcast Distributed Queue

    Я використовую той самий Hazelcast кластер що і logging сервіси щоб не перевантажувати віртуальну машину

- При надходженні POST-запиту до facade-service він має додавати повідомлення з запиту до черги повідомлень

    В facade-service в FacadeDomain додано функцію send_message_to_queue, яка відправляє повідомлення до черги  
    Ось процес запису повідомлень:
    ![Alt text](img/1.1.png?raw=true)  

- Копії messages-service мають вичитувати повідомлення (схема - producer/consumer) та зберегти їх у пам’яті 

    Ця логіка додана в клас MessageDomain

### Завдання

- Запустити три екземпляра logging-service (локально їх можна запустити на різних портах), відповідно мають запуститись також три екземпляра Hazelcast

    ![Alt text](img/1.2.png?raw=true)

- Запустити два екземпляри messages-service (локально їх можна запустити на різних портах)

    ![Alt text](img/1.3.png?raw=true)

- Через HTTP POST записати 10 повідомлень msg1-msg10 через facade-service

    Запустимо змінюючи номер 10 разів
    ![Alt text](img/1.4.png?raw=true)

- Показати які повідомлення отримав кожен з екземплярів logging-service (це має бути видно у логах сервісу)

    ![Alt text](img/1.5.png?raw=true)

- Показати які повідомлення отримав кожен з екземплярів messages-service (це має бути видно у логах сервісу)

    ![Alt text](img/1.6.png?raw=true)

- Декілька разів викликати HTTP GET на facade-service та отримати об'єднані дві множини повідомлень - це мають бути повідомлення з logging-service та messages-service

    Оскільки повідомлення просто поєднуються в порядку виконання, перевіримо з логів що пришло з якого сервісу   
    Перший запит 
    ![Alt text](img/1.7.png?raw=true)

    Повідомлення що пришли з logging сервісу  
    ![Alt text](img/1.8.png?raw=true)
    
    Тому перші 6 це повідомлення з message сервісу.
    Перевіримо їх айді з facade сервісу
    - "Message 1" має 468dbd5c-c288-11ed-8e03-08002704e8bc
    - "Message 2" має 49ccf7d0-c288-11ed-8e03-08002704e8bc
    - "Message 4" має 51523a74-c288-11ed-8e03-08002704e8bc
    - "Message 6" має 5bf9c88e-c288-11ed-8e03-08002704e8bc
    - "Message 8" має 607c0dae-c288-11ed-8e03-08002704e8bc
    - "Message 10" має 67a67e20-c288-11ed-8e03-08002704e8bc

    Саме ці айді записані в логах сервіса що працює на 30000 порту

    Наступний запит  
    ![Alt text](img/1.9.png?raw=true)
    Першими пришли повідомлення з logging сервісу, але бачимо що повторюються повідомлення яких немає на сервісі 30000, а сама 3, 5, 7, 9